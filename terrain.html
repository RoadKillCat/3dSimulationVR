<html>
<head>
	<script src="thirdEngine.js"></script>
	<script src="http://joeiddon.me/PerlinNoise/perlin.js"></script>
	<style>
	body {
		margin: 0;
		padding: 0;
	}
	#cnvs {
		background-color: black; 
		<!-- #FCFCDA; -->
	}	
	</style>
</head>

<body>
<canvas id="cnvs"></canvas>

<script>
var cnvs = document.getElementById("cnvs")
var ctx = cnvs.getContext("2d")

function fitCanvas(){
	cnvs.width = innerWidth
	cnvs.height = innerHeight
}
fitCanvas()
	
window.addEventListener("resize", ()=>{fitCanvas();restart();})
var randCol = () => "hsl(" + (1+Math.random()*359) + ",50%,60%)"

var interval = 0
var gridSize = 20
var cells = 4
var gridWidth = 1.5
var hillHeight = 6
var wireframe = true
var cam = {x: (gridSize/2) * gridWidth, y: -12, z: hillHeight + 1, yaw: 0, pitch: 0, roll: 0, fov: 80, step: 0.5, lookStep: 10}

function restart(){

//var world = [
//	{verts: [{x: -5,y: 10,z: 0}, {x: 5,y: 10,z: 0}, {x: 0,y: 10,z: 10}], col: "blue"}
//]
perlin.seed()
world = []
heights = []
flying = gridSize - 1
for (var r = 0; r < gridSize + 1; r++){
	var row = []
	for (var c = 0; c < gridSize + 1; c++){
		row.push(perlin.get(c * (cells/gridSize), r * (cells/gridSize)) * hillHeight)
	}
	heights.push(row)
}

for (var r = 0; r < gridSize; r++){
	for (var c = 0; c < gridSize; c++){
		var col = randCol()
		world.push(
			{verts: [{x: r * gridWidth, y: c * gridWidth, z: heights[c][r]},
			{x: r * gridWidth + gridWidth, y: c * gridWidth, z: heights[c][r+1]}, 
			{x: r * gridWidth, y: c * gridWidth + gridWidth, z: heights[c+1][r]}],
			col: col},
			
			{verts: [{x: r * gridWidth + gridWidth, y: c * gridWidth, z: heights[c][r+1]}, 
			{x: r * gridWidth + gridWidth, y: c * gridWidth + gridWidth, z:heights[c+1][r+1]}, 
			{x: r * gridWidth, y: c * gridWidth + gridWidth, z: heights[c+1][r]}],
			col: col}
	  )
	}
}

update()
}

restart()

function update(){
	render(world, cam, cnvs, wireframe)
	drawCross(cnvs.width/2, cnvs.height/2, 20)
}

window.addEventListener("keydown", function (event){
	var key = event.keyCode

	if (key == 67) restart()				//c for restart	
	if (key == 88) cam.z -= cam.step					//x	fly down
	if (key == 90) cam.z += cam.step					//z fly up
	if (key == 87) takeStep(cam.yaw)					//w	walk forward
	if (key == 83) takeStep(cam.yaw + 180)				//s walk backwards
	if (key == 65) takeStep(cam.yaw - 90)				//a walk left
	if (key == 68) takeStep(cam.yaw + 90)				//d walk right	
	if (key == 69) cam.yaw   += cam.lookStep			//e	look left
	if (key == 81) cam.yaw   -= cam.lookStep  			//q	look right
	if (key == 82) cam.pitch += cam.lookStep			//r	look up
	if (key == 70) cam.pitch -= cam.lookStep   			//f	look down
	if (key == 89) cam.roll  += cam.lookStep			//y roll left
	if (key == 84) cam.roll  -= cam.lookStep			//t roll right
	if (key == 66) toggleScroll()						//b toggle auto scroll
	if (key == 71) wireframe = !wireframe				//g toggle wireframe
	//if (key == 187) //+
	//if (key == 189) //-
	update()
})

function toggleScroll(){
	if (interval){
		clearInterval(interval)
		interval = 0
		wireframe = false
	} else {
		interval = setInterval(function(){
		flying += 1
		heights.shift(1)
		heights.push([])
		for (var c = 0; c < gridSize + 1; c++){
			heights[heights.length-1].push(perlin.get(c * (cells/gridSize), flying * (cells/gridSize)) * hillHeight)
		}
		world = []
		for (var r = 0; r < gridSize; r++){
			for (var c = 0; c < gridSize; c++){
				world.push({verts: [{x: r * gridWidth, y: c * gridWidth, z: heights[c][r]}, {x: r * gridWidth +gridWidth, y: c * gridWidth, z: heights[c][r+1]}, {x: r * gridWidth + gridWidth, y: c * gridWidth +gridWidth, z:heights[c+1][r+1]}, {x: r * gridWidth, y: c * gridWidth + gridWidth, z: heights[c+1][r]}], col: "#55ddcc"})
			}
		}
		wireframe = true
		update()
		}, 150)
	}
}


function takeStep(yaw){
	cam.x = cam.step * Math.sin(toRad(yaw)) + cam.x
	cam.y = cam.step * Math.cos(toRad(yaw)) + cam.y
}

function drawLine(xStart, yStart, xFin, yFin){					//draws a line on the canvas
   ctx.beginPath();
   ctx.moveTo(xStart, yStart);
   ctx.lineTo(xFin, yFin);
   ctx.strokeStyle = "white"
   ctx.stroke();
}

function drawCross(x, y, l){									//draws a cross on canvas in relation to the midpoint
	drawLine(x + l, y, x - l, y)
	drawLine(x, y + l, x, y - l)
}


</script>


</body>
</head>
